### This file generates synthetic data from GMM models trained in model_train.py.

### INPUT - model.json : output of model_train.py file.
###       - test_input.json : runway, procedural information for test.

### OUPUT - synthetic_trajs.csv : synthetic trajectories generated by the trained GMM model. Each row is a position of an aircraft [time, track_id, x, y, z].


import numpy as np
import matplotlib.pyplot as plt
import os, argparse
import json
import pymap3d as pm

from scipy import stats, interpolate
from scipy.interpolate import interp1d, PchipInterpolator


parser = argparse.ArgumentParser()
parser.add_argument("-i", "--input_files", nargs="*", required=True, help='model.json, test_input.json')
parser.add_argument("-o", "--output_file", required=True, help='synthetic trajs')
parser.add_argument("-mp", "--multi_processes", required=False, help='num processes')
args = parser.parse_args()

M_TO_NM = 0.000539957


# ### To save plots of each synthetic trajectory
# os.makedirs('data/synthetic_trajs_plot', exist_ok=True) 

# def plot_rwy(rwy_coords, color):
#     for r in rwy_coords:
#         a,b = r[0],r[1]
#         start_x, start_y, _ = pm.geodetic2enu(a[0], a[1], airport_altitude, airport_lat, airport_lon, airport_altitude)
#         end_x, end_y, _ = pm.geodetic2enu(b[0], b[1], airport_altitude, airport_lat, airport_lon, airport_altitude)
#         plt.plot([start_x*M_TO_NM, end_x*M_TO_NM], [start_y*M_TO_NM, end_y*M_TO_NM], '--', c=color, lw=1)
#     plt.scatter(0, 0, s=4, c=color, marker='*')


###########################################################################
########################     Load model.json     ##########################
###########################################################################

### load model.json file
with open(args.input_files[0], "r") as f:
    model = json.load(f)

# IAP segment model
IAP_model = model["IAP_model"]
IAP_means, IAP_covs = np.array(IAP_model["means"]), np.array(IAP_model["covs"])
IAP_means_dist_time, IAP_covs_dist_time = np.array(IAP_model['means_dist_time']), np.array(IAP_model['covs_dist_time'])
      
# vector segment model
vector_model = model["vector_model"]
vector_means, vector_covs, vector_cluster_probs = np.array(vector_model["means"]), np.array(vector_model["covs"]), np.array(vector_model['cluster_probs'])
vector_means_dist_time, vector_covs_dist_time = np.array(vector_model['means_dist_time']), np.array(vector_model['covs_dist_time'])
      
# departure model
dep_model = model["departure_model"]
dep_means, dep_covs, dep_cluster_probs = np.array(dep_model["means"]), np.array(dep_model["covs"]), np.array(dep_model['cluster_probs'])
dep_means_dist_time, dep_covs_dist_time = np.array(dep_model['means_dist_time']), np.array(dep_model['covs_dist_time'])

    
# inter flight distributions
inter_arrdep_distr = model["inter_arrdep_model"]["distribution"]

arr_arr_model = model["inter_arrdep_model"]["arr_arr"]
arr_arr_means, arr_arr_covs, arr_arr_cluster_probs = np.array(arr_arr_model["means"]), np.array(arr_arr_model["covs"]), np.array(arr_arr_model["cluster_probs"])
arr_dep_model = model["inter_arrdep_model"]["arr_dep"]
arr_dep_means, arr_dep_covs, arr_dep_cluster_probs = np.array(arr_dep_model["means"]), np.array(arr_dep_model["covs"]), np.array(arr_dep_model["cluster_probs"])
dep_arr_model = model["inter_arrdep_model"]["dep_arr"]
dep_arr_means, dep_arr_covs, dep_arr_cluster_probs = np.array(dep_arr_model["means"]), np.array(dep_arr_model["covs"]), np.array(dep_arr_model["cluster_probs"])
dep_dep_model = model["inter_arrdep_model"]["dep_dep"]
dep_dep_means, dep_dep_covs, dep_dep_cluster_probs = np.array(dep_dep_model["means"]), np.array(dep_dep_model["covs"]), np.array(dep_dep_model["cluster_probs"])



##########################################################################
######################    Load test_input.json    ########################
##########################################################################

### load test_input.json file
with open(args.input_files[1], "r") as f:
    data = json.load(f)

### airport, runway configuration
airport_name = data["airport_name"]
airport_lat, airport_lon, airport_altitude = data["airport_coordinate"]
rwy_names = data["runways_configuration"]["rwy_names"]
rwy_coords = data["runways_configuration"]["rwy_coordinates"]

### operation_type (arrival and/or departure)
operation_arrivals = data["operation_type"]["arrivals"]
operation_departures = data["operation_type"]["departures"]
print('operate arrivals :', operation_arrivals == 1)
print('operate departures :', operation_departures == 1)

### runway_in_use
arr_rwy = data["runway_in_use"]["arrivals"]["rwy"]  
arr_RWY = np.array(data["runway_in_use"]["arrivals"]["rwy_coordinates"])
arr_ENU_RWY = np.array([pm.geodetic2enu(fix[0], fix[1], fix[2], airport_lat, airport_lon, airport_altitude) for fix in arr_RWY])

arr_RWY_x_interp = np.linspace(arr_ENU_RWY[0][0], arr_ENU_RWY[-1][0], num=50, endpoint=True)
arr_RWY_y_interp = np.linspace(arr_ENU_RWY[0][1], arr_ENU_RWY[-1][1], num=50, endpoint=True)


########################################################
### IAP
IAP = np.array(data["runway_in_use"]["arrivals"]["IAP_path"])
IF_min_alt = IAP[0][2]
ENU_IAP = np.array([pm.geodetic2enu(fix[0], fix[1], fix[2], airport_lat, airport_lon, airport_altitude) for fix in IAP])

# IAP_x, IAP_y coordinates
IAP_x_interp = np.linspace(ENU_IAP[0][0], ENU_IAP[-1][0], num=100, endpoint=True) 
IAP_y_interp = np.linspace(ENU_IAP[0][1], ENU_IAP[-1][1], num=100, endpoint=True)

IAP_RWY_x = np.concatenate((IAP_x_interp[:-1], arr_RWY_x_interp), axis=0)
IAP_RWY_y = np.concatenate((IAP_y_interp[:-1], arr_RWY_y_interp), axis=0)

interpSpl, u = interpolate.splprep([IAP_RWY_x, IAP_RWY_y], s=10)
u_interp = np.linspace(0, 1, num=100)
[IAP_RWY_x_interp, IAP_RWY_y_interpSpl] = interpolate.splev(u_interp, interpSpl, der=0)
IAP_RWY_xy_interp = np.column_stack((IAP_RWY_x_interp[:],IAP_RWY_y_interpSpl[:]))

IAP_RWY_idx = np.argmin(np.linalg.norm(IAP_RWY_xy_interp - arr_ENU_RWY[0][:2], 1, axis=1))
IAP_final_xy = IAP_RWY_xy_interp[:IAP_RWY_idx]
    
# IAP_z coordinates
IAP_indices = [np.argmin(np.linalg.norm(IAP_RWY_xy_interp - fix[:2], 1, axis=1)) for fix in ENU_IAP]
if IAP_indices[-1] != IAP_RWY_idx:
    f = interp1d(IAP_indices[:-1] + [IAP_RWY_idx], np.append(ENU_IAP[:-1,2], [0])) 
else:
    f = interp1d(IAP_indices, ENU_IAP[:,2])   
t_interp = range(0, IAP_RWY_idx)
IAP_final_z = f(t_interp)

# final IAP coordinates
IAP_final = np.column_stack((IAP_final_xy, IAP_final_z))

# smooth path
t = np.linspace(0, 150, len(IAP_final))
t_interp = np.array(range(0, 150))
test_IAP_path = np.zeros((t_interp.shape[-1], 3))
test_IAP_path[:, 0] = PchipInterpolator(t, IAP_final[:,0])(t_interp)
test_IAP_path[:, 1] = PchipInterpolator(t, IAP_final[:,1])(t_interp) 
test_IAP_path[:, 2] = PchipInterpolator(t, IAP_final[:,2])(t_interp)


########################################################
### vector paths
vector_paths = np.array(data["runway_in_use"]["arrivals"]["vector_paths"])
test_vector_paths = []
for path in vector_paths:
    ENU_path = np.array([pm.geodetic2enu(fix[0], fix[1], fix[2], airport_lat, airport_lon, airport_altitude) for fix in path])
    
    # smooth path
    t = np.linspace(0, 350, len(ENU_path))
    t_interp = np.array(range(0, 350))
    ENU_path_interp = np.zeros((t_interp.shape[-1], 3))
    ENU_path_interp[:, 0] = PchipInterpolator(t, ENU_path[:,0])(t_interp)
    ENU_path_interp[:, 1] = PchipInterpolator(t, ENU_path[:,1])(t_interp)
    ENU_path_interp[:, 2] = PchipInterpolator(t, ENU_path[:,2])(t_interp)
    test_vector_paths.append(ENU_path_interp)
test_vector_paths_weights = data["runway_in_use"]["arrivals"]["vector_paths_weights"]
    
    
########################################################
### departure paths
dep_paths = np.array(data["runway_in_use"]["departures"]["dep_paths"])
test_dep_paths = []
for path in dep_paths:
    ENU_path = np.array([pm.geodetic2enu(fix[0], fix[1], fix[2], airport_lat, airport_lon, airport_altitude) for fix in path])
    
    # smooth path
    t = np.linspace(0, 250, len(ENU_path))
    t_interp = np.array(range(0, 250))
    ENU_path_interp = np.zeros((t_interp.shape[-1], 3))
    ENU_path_interp[:, 0] = PchipInterpolator(t, ENU_path[:,0])(t_interp)
    ENU_path_interp[:, 1] = PchipInterpolator(t, ENU_path[:,1])(t_interp) 
    ENU_path_interp[:, 2] = PchipInterpolator(t, ENU_path[:,2])(t_interp)
    test_dep_paths.append(ENU_path_interp)
test_dep_paths_weights = data["runway_in_use"]["departures"]["dep_paths_weights"]
    


#############################################################################
#####################    Generate synthetic trajs    ########################
#############################################################################

num_syn_trajs = data['num_syn_trajs']

if operation_arrivals == 1 and operation_departures == 0:
    arrdep_mix = [0] * num_syn_trajs 
elif operation_arrivals == 0 and operation_departures == 1:
    arrdep_mix = [1] * num_syn_trajs
elif operation_arrivals == 1 and operation_departures == 1:
    arrdep_mix = []
    arrdep = 0  #[0:arr, 1:dep]
    for i in range(num_syn_trajs):
        if arrdep == 0:
            arrdep_mix.append(np.random.choice(range(2), 1, [inter_arrdep_distr[0], inter_arrdep_distr[1]])[0]) 
        if arrdep == 1:
            arrdep_mix.append(np.random.choice(range(2), 1, [inter_arrdep_distr[2], inter_arrdep_distr[3]])[0])



outputFile = open(args.output_file, "w")
outputFile.close()

# all_recon_trajs=[]
for i, arrdep_ind in enumerate(arrdep_mix):
    if arrdep_ind == 0:
        
        ########################################################################
        ### vector segment
        p_ind = np.random.choice(range(len(test_vector_paths_weights)), 1, p=test_vector_paths_weights)[0]
        vector_nominal_path = test_vector_paths[p_ind]
        vector_nominal_path_dist = np.sum([np.linalg.norm((vector_nominal_path[j,1:3], vector_nominal_path[j+1, 1:3]), 2) for j in range(len(vector_nominal_path)-1)])
        vector_paths_dist = vector_means[:,-1]
        vector_ind = np.argmin(np.abs(vector_nominal_path_dist - vector_paths_dist))
        
        vector_mean = vector_means[vector_ind] 
        vector_cov = vector_covs[vector_ind]
        vector_syn_dev = np.random.multivariate_normal(vector_mean, vector_cov, 1)
        
        
        # transit time given distance
        given_b = vector_syn_dev[0,-1]  #vector_total_dist
        dt_ind = np.argmin(np.abs(vector_means_dist_time[:,0] - given_b))

        mu_a = vector_means_dist_time[dt_ind,1].reshape(1,)  #mean_1
        mu_b = vector_means_dist_time[dt_ind,0].reshape(1,)  #mean_2
        sigma_A = vector_covs_dist_time[dt_ind,1,1].reshape(-1,1)  #cov_11 
        sigma_B = vector_covs_dist_time[dt_ind,0,0].reshape(-1,1)   #cov_22
        sigma_C = vector_covs_dist_time[dt_ind,1,0].reshape(-1,1)   #cov_12

        mu_a_b = mu_a + sigma_C.dot(np.linalg.inv(sigma_B)).dot(given_b - mu_b)  #mean_1|2 
        sigma_a_b = sigma_A - sigma_C.dot(np.linalg.inv(sigma_B)).dot(sigma_C.T)  #cov_1|2    
        vector_transit_t = np.random.multivariate_normal(mu_a_b, sigma_a_b, 1)
        
        # reconstruct vector trajectory
        vector_nominal_path = vector_nominal_path.reshape(vector_nominal_path.shape[0]*vector_nominal_path.shape[1])
        vector_recon_traj = vector_syn_dev[0,1:-1] + vector_nominal_path

        
        ########################################################################
        ### IAP segment 
        ### (sampling IAP_seg traj, conditioned on the last 'obs_p' points of vector_seg traj)
        obs_p = 10  #number of last points of vector_segment

        IAP_nominal_path_original = test_IAP_path
        IAP_nominal_path = IAP_nominal_path_original.reshape(IAP_nominal_path_original.shape[0]*IAP_nominal_path_original.shape[1])  

        given_b = vector_recon_traj[-obs_p*3:] - IAP_nominal_path[:obs_p*3]
        paths_obs_p = IAP_means[:,1:1+obs_p*3]
        given_b_temp = given_b.reshape(-1,3)[:,:2].reshape(obs_p*2)
        paths_obs_p_temp = paths_obs_p.reshape(paths_obs_p.shape[0],-1,3)[:,:,:2].reshape(paths_obs_p.shape[0],obs_p*2)

        IAP_ind = np.argmin(np.linalg.norm(given_b_temp - paths_obs_p_temp, 2, axis=1))


        # conditional sampling
        mu_a = np.zeros((IAP_means[IAP_ind].shape[0] - obs_p*3 - 1))
        mu_b = np.zeros((obs_p*3,)) 
        sigma_A = IAP_covs[IAP_ind, 1+obs_p*3:, 1+obs_p*3:] 
        sigma_B = IAP_covs[IAP_ind, 1:1+obs_p*3, 1:1+obs_p*3] 
        sigma_C = IAP_covs[IAP_ind, 1+obs_p*3:, 1:1+obs_p*3]

        mu_a_b = mu_a + sigma_C.dot(np.linalg.inv(sigma_B)).dot(given_b - mu_b) 
        sigma_a_b = sigma_A - sigma_C.dot(np.linalg.inv(sigma_B)).dot(sigma_C.T) 
        IAP_syn_dev = np.random.multivariate_normal(mu_a_b, sigma_a_b, 1)
        

        # transit time given distance
        given_b = IAP_syn_dev[0,-1]  ## IAP distance
        dt_ind = np.argmin(np.abs(IAP_means_dist_time[:,0] - given_b))

        mu_a = IAP_means_dist_time[dt_ind,1].reshape(1,)  
        mu_b = IAP_means_dist_time[dt_ind,0].reshape(1,) 
        sigma_A = IAP_covs_dist_time[dt_ind,1,1].reshape(-1,1) 
        sigma_B = IAP_covs_dist_time[dt_ind,0,0].reshape(-1,1)  
        sigma_C = IAP_covs_dist_time[dt_ind,1,0].reshape(-1,1) 

        mu_a_b = mu_a + sigma_C.dot(np.linalg.inv(sigma_B)).dot(given_b - mu_b)  
        sigma_a_b = sigma_A - sigma_C.dot(np.linalg.inv(sigma_B)).dot(sigma_C.T)

        # reconstruct IAP trajectory
        IAP_transit_t = np.random.multivariate_normal(mu_a_b, sigma_a_b, 1)  
        IAP_recon_traj = IAP_syn_dev[0,:-1] + IAP_nominal_path[obs_p*3:]

        
        ########################################################################
        ### vector + IAP
        # whole transit time
        whole_transit_t = vector_transit_t[0] + IAP_transit_t[0]
        whole_transit_t = np.min((np.max((whole_transit_t, 600)), 1200))

        target_length = (len(vector_recon_traj) + len(IAP_recon_traj)) // 3 
        transit_t_traj = np.linspace(0, whole_transit_t, num=target_length, endpoint=True)

        # sample inter_arrdep time
        if i==0:  #if first flight in the mix
            rwy_time = transit_t_traj[-1]
        elif arrdep_mix[i-1] == 0:  #if previous flight was also arrival, sample from arr_arr_model
            c_ind = np.random.choice(range(len(arr_arr_cluster_probs)), 1, p=arr_arr_cluster_probs)[0]
            mu = arr_arr_means[c_ind]
            sigma = np.sqrt(arr_arr_covs[c_ind])
            inter_arrdep_time = stats.truncnorm.rvs((120-mu)/sigma,1.96,loc=mu,scale=sigma,size=1)
            rwy_time = old_rwy_time + inter_arrdep_time 
        elif arrdep_mix[i-1] == 1:  #if previous flight was departure, sample from dep_arr_model
            c_ind = np.random.choice(range(len(dep_arr_cluster_probs)), 1, p=dep_arr_cluster_probs)[0]
            mu = dep_arr_means[c_ind]
            sigma = np.sqrt(dep_arr_covs[c_ind])
            inter_arrdep_time = stats.truncnorm.rvs((120-mu)/sigma,1.96,loc=mu,scale=sigma,size=1)
            rwy_time = old_rwy_time + inter_arrdep_time
        recon_time_traj = rwy_time - transit_t_traj[::-1]
        
        # reconstruct trajectory
        recon_traj = np.concatenate((vector_recon_traj, IAP_recon_traj))
        x_ind = [i%3 == 0 for i in range(len(recon_traj))]
        y_ind = [i%3 == 1 for i in range(len(recon_traj))]
        z_ind = [i%3 == 2 for i in range(len(recon_traj))]
        traj = np.column_stack((recon_time_traj, recon_traj[x_ind], recon_traj[y_ind], recon_traj[z_ind]))
      
    
    ########################################################################
    ### departure 
    if arrdep_ind == 1:
        
        p_ind = np.random.choice(range(len(test_dep_paths_weights)), 1, p=test_dep_paths_weights)[0]
        dep_nominal_path = test_dep_paths[p_ind]  ##(350,3)
        dep_nominal_path_dist = np.sum([np.linalg.norm((dep_nominal_path[j,1:3], dep_nominal_path[j+1, 1:3]), 2) for j in range(len(dep_nominal_path)-1)])
        dep_paths_dist = dep_means[:,-1]
        dep_ind = np.argmin(np.abs(dep_nominal_path_dist - dep_paths_dist))
        
        dep_mean = dep_means[dep_ind] 
        dep_cov = dep_covs[dep_ind]
        dep_syn_dev = np.random.multivariate_normal(dep_mean, dep_cov, 1) # (1,752)
        
        
        # transit time given distance
        given_b = dep_syn_dev[0,-1]  # departure distance
        dt_ind = np.argmin(np.abs(dep_means_dist_time[:,0] - given_b))

        mu_a = dep_means_dist_time[dt_ind,1].reshape(1,)  
        mu_b = dep_means_dist_time[dt_ind,0].reshape(1,) 
        sigma_A = dep_covs_dist_time[dt_ind,1,1].reshape(-1,1)
        sigma_B = dep_covs_dist_time[dt_ind,0,0].reshape(-1,1)
        sigma_C = dep_covs_dist_time[dt_ind,1,0].reshape(-1,1)

        mu_a_b = mu_a + sigma_C.dot(np.linalg.inv(sigma_B)).dot(given_b - mu_b) 
        sigma_a_b = sigma_A - sigma_C.dot(np.linalg.inv(sigma_B)).dot(sigma_C.T)  
        dep_transit_t = stats.truncnorm.rvs((120-mu_a_b)/sigma_a_b, 2.58, loc=mu_a_b, scale=sigma_a_b, size=1)

        
        # reconstruct time trajectory & departure trajectory
        dep_nominal_path = dep_nominal_path.reshape(dep_nominal_path.shape[0]*dep_nominal_path.shape[1])  
        dep_recon_traj = dep_syn_dev[0,1:-1] + dep_nominal_path
        
        target_length = len(dep_recon_traj) // 3  
        transit_t_traj = np.linspace(0, dep_transit_t, num=target_length, endpoint=True)
         
            
        # sample inter_arrdep time
        if i==0:  #if first flight in the mix
            rwy_time = transit_t_traj[0]
        elif arrdep_mix[i-1] == 0:  #if previous flight was arrival, sample from arr_dep_model
            c_ind = np.random.choice(range(len(arr_dep_cluster_probs)), 1, p=arr_dep_cluster_probs)[0]
            mu = arr_dep_means[c_ind]
            sigma = np.sqrt(arr_dep_covs[c_ind])
            inter_arrdep_time = stats.truncnorm.rvs((120-mu)/sigma,1.96,loc=mu,scale=sigma,size=1)
            rwy_time = old_rwy_time + inter_arrdep_time 
        elif arrdep_mix[i-1] == 1:  #if previous flight was also departure, sample from dep_dep_model
            c_ind = np.random.choice(range(len(dep_dep_cluster_probs)), 1, p=dep_dep_cluster_probs)[0]
            mu = dep_dep_means[c_ind]
            sigma = np.sqrt(dep_dep_covs[c_ind])
            inter_arrdep_time = stats.truncnorm.rvs((120-mu)/sigma,1.96,loc=mu,scale=sigma,size=1)
            rwy_time = old_rwy_time + inter_arrdep_time
        recon_time_traj = rwy_time + transit_t_traj
        
        # reconstruct trajectory
        x_ind = [i%3 == 0 for i in range(len(dep_recon_traj))]
        y_ind = [i%3 == 1 for i in range(len(dep_recon_traj))]
        z_ind = [i%3 == 2 for i in range(len(dep_recon_traj))]
        traj = np.column_stack((recon_time_traj, dep_recon_traj[x_ind], dep_recon_traj[y_ind], dep_recon_traj[z_ind]))


    ### smooth the trajectory
    t = traj[:,0]

    smooth_length = len(traj) // 25
    t_smooth_0 = np.linspace(t.min(), t.max()+1, num=smooth_length, endpoint=True)
    traj_smooth_0 = np.zeros((t_smooth_0.shape[-1], 4))
    traj_smooth_0[:, 0] = t_smooth_0
    traj_smooth_0[:, 1] = PchipInterpolator(t, traj[:,1])(t_smooth_0)
    traj_smooth_0[:, 2] = PchipInterpolator(t, traj[:,2])(t_smooth_0)
    traj_smooth_0[:, 3] = PchipInterpolator(t, traj[:,3])(t_smooth_0)

    t_smooth = np.arange(t.min(), t.max()+1)
    traj_smooth = np.zeros((t_smooth.shape[-1], 5))
    traj_smooth[:, 0] = t_smooth  #time
    traj_smooth[:, 1] = np.int(i+1)  #track_id
    traj_smooth[:, 2] = PchipInterpolator(t_smooth_0, traj_smooth_0[:,1])(t_smooth)  #xEast
    traj_smooth[:, 3] = PchipInterpolator(t_smooth_0, traj_smooth_0[:,2])(t_smooth)  #yNorth
    traj_smooth[:, 4] = PchipInterpolator(t_smooth_0, traj_smooth_0[:,3])(t_smooth)  #zUp

    # all_recon_trajs.append(traj_smooth) 
    old_rwy_time = rwy_time
    

    outputFile = open(args.output_file,"a")
    for point in traj_smooth:
        for item in point:
            outputFile.write(str(item) + ',')
        outputFile.write('\n')
    outputFile.close()

    
    ### To save plots of each synthetic trajectory
    # if arrdep_ind == 0:
    #     plt.figure(figsize=(5,5)); plt.xlabel('East (NM)'); plt.ylabel('North (NM)')
    #     plt.xlim([-30, 30]); plt.ylim([-30, 30]); plot_rwy(rwy_coords, color='black');
    #
    #     plt.plot(IAP_nominal_path_original[:,0]*M_TO_NM, IAP_nominal_path_original[:,1]*M_TO_NM, '-.', c='black')
    #     plt.plot(vector_recon_traj[-obs_p*3:].reshape(obs_p, 3)[:,0]*M_TO_NM, vector_recon_traj[-obs_p*3:].reshape(obs_p, 3)[:,1]*M_TO_NM, c='red', lw=5)
    #
    #     recon_t_ind = np.argmin(np.abs(traj_smooth[:,0] - recon_time_traj[350]))
    #     plt.plot(traj_smooth[:recon_t_ind,2]*M_TO_NM, traj_smooth[:recon_t_ind,3]*M_TO_NM, '-.', c='blue')
    #     plt.plot(traj_smooth[recon_t_ind:,2]*M_TO_NM, traj_smooth[recon_t_ind:,3]*M_TO_NM, '--', c='blue')
    #     plt.savefig('data/synthetic_trajs_plot/synthetic_traj_%s' % i)
    #     plt.close()
    #
    # elif arrdep_ind == 1:
    #     plt.figure(figsize=(5,5)); plt.xlabel('East (NM)'); plt.ylabel('North (NM)')
    #     plt.xlim([-30, 30]); plt.ylim([-30, 30]); plot_rwy(rwy_coords, color='black');
    #     plt.plot(traj_smooth[:,2]*M_TO_NM, traj_smooth[:,3]*M_TO_NM, '-.', c='green')
    #     plt.savefig('data/synthetic_trajs_plot/synthetic_traj_%s' % i)
    #     plt.close()

